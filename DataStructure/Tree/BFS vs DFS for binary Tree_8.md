# BFS(广度优先搜索)和DFS(深度优先搜索)的比较

# Abstract
> 二叉树的BFS和DFS是什么?
> 树通常有两种遍历方式:
>1. 广度优先遍历（或级别顺序遍历）
>2. 深度优先遍历 
> - Inorder Traversal (Left-Root-Right) 左根右
> - Preorder Traversal (Root-Left-Right) 根左右
> - Postorder Traversal (Left-Right-Root) 左右根 如下图的树
> 
> ![树实例](_v_images/20190422074508268_13412.gif)  
> 
> BFS 和 DFS方法遍历上面的树
> * 广度优先遍历：1 2 3 4 5
> * 深度优先遍历
> 1.前序遍历： 1 2 4 5 3
> 2.中序遍历： 4 2 5 1 3
> 3.后序遍历： 4 5 2 3 1

## 为什么要关心这个
>有许多树问题可以使用上述四种遍历中的任何一种来解决。  
>这类问题的例子有大小、最大值、最小值、打印左视图等。

## 他们的时间复杂度如何
>上面的四种遍历方法都需要O(n)的时间复杂度

## 在额外空间方法有什么不同
>所需的额外空间有所不同。
>1. 层级顺序遍历所需的额外空间是O(w),其中w是二叉树的最大宽度。
>在级别顺序遍历中，队列逐个存储不同级别的节点。
>2. 深度优先遍历所需的额外空间为O(h),其中h是二叉树的最大高度。在深度优先遍历中  
>堆栈（或函数调用堆栈）存储节点的所有祖先。  
>通过验证能得到结论：  
>**如果树太过平衡时候，对于广优先遍历二叉树需要的额外空间更多。当平衡太少的时候
>深度优先遍历需要的额外空间更多**


## 如何选择
>1. 额外空间是一个因素
>2. 深度优先遍历通常是递归的，递归代码需要函数调用开销。
>3. 最重要的一点是，BFS从根节点开始访问节点，而DFS从叶子节点开始访问节点。
>所以如果我们的问题是搜索更接近根的东西，我们使用BFS。
>如果目标节点接近叶子节点，我们使用DFS。