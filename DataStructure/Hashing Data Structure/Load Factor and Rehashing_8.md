# Load Factor and Rehashing


## Hasing如何工作
>对于插入key-value(键值对)大概需要以下几个步骤。  
>1. 将K通过hash方法转换为一个更小的数(称为哈希编码)。
>2. 哈希编码常用于查找索引，并且会首先在整个链表中查找是否已经存在K。
>3. 如果找到，则将值更新，如果没有找到，则将键值对存储在新的节点上。

## 复杂度和加载因子
>第一步，时间取决于K和哈希函数，例如，如果一个key是一个字符串"abcd"，它的hash function可能取决于字符串的长度。
>但是对于一个很大的值n，它进入map中的数量，相比于n可以几乎忽略不计，所以hash function的时间复杂度可以认为是一个
>常量O(1)。  
>对于第二步，使用index遍历整个key-value对的列表，此时有种最坏的情况就是所有的输入项n他们都有相同索引，所以时间
>复杂度为O(n)，但是如果使得哈希方法的分配每个桶的几率是平均的，那么这样一直重复的情况就不会发生。
>所以平均的情况下，如果有n个待插入项目，并且数组的长度为b，那么对于每个项目出现索引值相同 的概率为n/b，把n/b的值称为**载入因子**，
>它代表着我们map上负载。
>**载入因子**通常都要保持比较低，这样的话能够使得每个索引的出现概率减少，并且使其时间复杂度为常数O(1)。



## 再哈希(Rahashing)
>正如其名字一样，再哈希就是再一次使用哈希方法。当负载系数增加到超过其预定值（负载系数一般默认为0.75）时，
>时间复杂度增加。所以为了解决这个问题，增加数组的长度(翻倍)并且所有的值都再一次调用哈希方法，然后再存入
>新的数组中，保持其低载入因子和低时间复杂度。


## 为什么要再哈希
>在键值对插入到map中，载入因子值增大，那么意味着时间复杂度也增加了，可能不能够有较稳定的O(1)的时间复杂度。
>因此，必须要再哈希，增加数组的长度，即增加哈希桶的数量，这样以来能够有效的减小载入因子和时间复杂度。


## 如何完成再哈希
>1. 每当一个新条目进入到map中，检查载入因子
>2. 如果载入因子大于预设的值，则再哈希
>3. 对于再哈希，使得新的桶数组的大小是之前桶数组大小的两倍，并且构造新的哈希桶数组
>4. 遍历原有桶数组中的每一个元素，并且调用insert()方法插入到新的更大的桶数组中。


