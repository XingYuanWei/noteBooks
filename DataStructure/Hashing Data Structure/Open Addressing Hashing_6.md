# Open Addressing
> 像使用分离链表一样，开放寻址也是一个处理碰撞的方法。在开放寻址中，所有的元素都能存储在
> hash table中，所有在任何时候，表的大小一定要大于或等于键的总数。
>insert(k)：持续搜索直到发现新的空插槽，一旦发现一个新的空插槽，则插入k  
>search(k)：持续搜索直到槽的键不等于k或到达一个空槽为止  
>delete(k)：删除操作十分有意思，如果我们冒然的删除一个键，那么可能会导致之后的search方法
>失败，所以槽中的键只是被标记为"deleted"而不是真的删除了，插入时候则可以把这个被标记"deleted"
>的元素覆盖。但是搜索的时候不会在这个被标记元素中停止。




## 开放寻址按以下方式完成
#### 1.线性探测
>例如：我们使用哈希方法hash(x)计算出槽的索引，S表示表的大小  
>如果hash(x) % S计算出的槽是有数值的，那么我们尝试(hash(x)  + 1) % S  
>如果(hash(x) + 1) % S也是满的，那么我们尝试(hash(x) + 2) % S  
>如果(hash(x) + 2) % S也是满的，那么我们尝试(hash(x) + 4) % S
>..................  
>让我们想象一个简单的hash  function比如 "key mod 7"，并且有序列50,700，76，85,92，73，101

![线性探测](_v_images/20190312080904564_28728.png)

#### 2.Clustering