vnote_backup_file_826537664 F:/VNote/数据结构/LinkedList/17 Remove duplicates from and unsorted Linked List.md
# 17 Remove duplicates from and unsorted Linked List

## Abstract
> 写一个名为removeDupFromUnsorted的方法，从一个无序的Linked List中删去重复的元素。  
> 比如有一个Linked List为：  12->11->12->21->41->43->21。  
> 经过调用removeDuplicates()方法后
> 可以将Linked  List转换为：12->11->21->41->43.


## 思路
>* #### 方法一
>有一个很简单也很直接的方法，就是使用两个循环。循环选择选择一个元素，内层循环将剩余的元素一个一个的与外层循环选择出的元素进行比较，
>如果与外层循环的元素相同的话，那么将这个元素删去并释放内存空间。
>代码如下:
```c++
        void removeDupFromUnsortedList(Node * head_ref)
        {
            	//第一层循环的的引用，第二层循环的引用，要被删去元素的引用
            	struct Node* outer_ptr, *inner_ptr, *del;
            	outer_ptr = head_ref;
        	
        	//外层循环一个个的选择元素
        	while (outer_ptr != NULL && outer_ptr->next != NULL)
        	{
        		inner_ptr = outer_ptr;
        		//将选择出的一个元素与Linked List中剩余的元素进行比较
        		while (inner_ptr->next != NULL)
        		{
        			//如果选择出的元素内容与剩余的某个元素内容相同则删去这个
        			//再剩余元素中重复的元素，而不是删去这个被选出的元素
        			if (outer_ptr->data == inner_ptr->next->data)
        			{
        				//以下操作的顺序十分重要不能有错

        				//1.先将重复的元素赋值给del指针
        				del = inner_ptr->next;
        				//2.再把Linked List指针指向 将要被删去元素 的下一个元素
        				inner_ptr->next = inner_ptr->next->next;
        				//3.释放内存
        				//delete(del);
        				free(del);
        				/*
        					补充一下free和delete的区别
        					首先free对应的是malloc；delete对应的是new；
        					free用来释放malloc出来动态内存，
        					delete用来释放new出来的动态内存空间。
        				*/
        			}
        			else
        			{
        				inner_ptr = inner_ptr->next;
        			}
        		}
        		//外层循环指针指向下一个元素
        		outer_ptr = outer_ptr->next;
        	}
        }
```  

## 方法一的完整代码：

>完整代码
```c++
    #include <cstdio>
    #include <cstdlib>
    #include <iostream>
    #include <cassert>
    
    //添加到Linked List最前
    void push(struct Node** head_ref, int new_data);
    //从指定节点向后打印
    void printList(struct Node* node);
    //从无序Linked List移去重复节点
    removeDupFromUnsortedList(Node * head_ref);


    struct Node
    {
    	int data;
    	struct Node *next;
    };
    
    int main(){
      struct Node* head = NULL;
      push(&head, 4);
    	push(&head, 13);
    	push(&head, 11);
    	push(&head, 18);
    	push(&head, 11);
    	push(&head, 34);
    	push(&head, 18);
    	push(&head, 11);

    	printf("Linked list before duplicate removal:\n");
    	printList(head);
    	//调用方法
    	removeDupFromUnsortedList(head);
    	
    	printf("Linked list after duplicate removal:\n");
    	printList(head);
    	return 0;
    }
    
    void push(struct Node** head_ref, int new_data) {
    	//1.allocate node
    	struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    	//2. put in the data;
    	new_node->data = new_data;
    	//3.make next of new node as head
    	new_node->next = *head_ref;
    	//4.move the head to point to the new node;
    	*head_ref = new_node;
   }
     
    void removeDupFromUnsortedList(Node * head_ref)
    {
    	//第一层循环的的引用，第二层循环的引用，要被删去元素的引用
    	struct Node* outer_ptr, *inner_ptr, *del;
    	outer_ptr = head_ref;
    	
    	//外层循环一个个的选择元素
    	while (outer_ptr != NULL && outer_ptr->next != NULL)
    	{
    		inner_ptr = outer_ptr;
    		//将选择出的一个元素与Linked List中剩余的元素进行比较
    		while (inner_ptr->next != NULL)
    		{
    			//如果选择出的元素内容与剩余的某个元素内容相同则删去这个
    			//再剩余元素中重复的元素，而不是删去这个被选出的元素
    			if (outer_ptr->data == inner_ptr->next->data)
    			{
    				//以下操作的顺序十分重要不能有错

    				//1.先将重复的元素赋值给del指针
    				del = inner_ptr->next;
    				//2.再把Linked List指针指向 将要被删去元素 的下一个元素
    				inner_ptr->next = inner_ptr->next->next;
    				//3.释放内存
    				//delete(del);
    				free(del);
    				/*
    					补充一下free和delete的区别
    					首先free对应的是malloc；delete对应的是new；
    					free用来释放malloc出来动态内存，
    					delete用来释放new出来的动态内存空间。
    				*/
    			}
    			else
    			{
    				inner_ptr = inner_ptr->next;
    			}
    		}
    		//外层循环指针指向下一个元素
    		outer_ptr = outer_ptr->next;
    	}
    }
   
    //打印链表的内容
    void printList(struct Node* node) {
    	while (node != NULL)
    	{
    		printf("%d\n", node->data);
    		node = node->next;
    	}
    }
```

* #### 方法二
