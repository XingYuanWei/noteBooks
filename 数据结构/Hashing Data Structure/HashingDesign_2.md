# Hashing Design


## Abstract
> 假定我们想要设计一个系统用于存储雇员信息，用他们的电话号码作为键。并且我们希望能够执行以下的有效查询。  
> 1. 插入一个电话号码和相应的信息
> 2. 搜索到电话号码和获取信息
> 3. 删除一个电话号码和相关的信息

> 我们可以想到使用以下的数据结构保存关于不同电话号码的信息  
> 1. 电话号码和记录的数组
> 2. 电话号码和记录的Linked List
> 3. 用电话号码作为键的二叉搜索树
> 4. 直接访问表


## 分析
>#### 1.
>对于数组和链表，通常需要线性的时间用于搜索，这样的方式在实际情况中花费是十分昂贵的。
>#### 2.
>如果我们使用数组并且保证其数据的排序，使用二叉搜索树查询电话号码， 这样花费的时间复杂度为
>O(logn),但是插入和删除操作消耗不小并且还需要额外的保存排序状态。
>#### 3.
> 对于平衡二叉树，我们可以使用比较折中(中等，温和)的方式，对于插入和删除，所有的
> 这些操作都能保证时间复杂度为O(Logn)。
>#### 4.
> 另一种解决方案是我们可以制造一个大数组并在数组中使用电话号码作为索引，
> 制造一个比较大的直接访问表。输入一个电话号码，如果该电话号码存在，
> 则返回对应的记录。这个方法比以上所有的方法都要好，因为我们可以
> 确保时间复杂度都为O(1)。例如我们要插入一个电话号码信息，我们可以使用给定的电话号码
> 信息和它的细节创建一条记录，使用电话号码作为索引并且存储让指针指向这个被创建的记录。
> 但是这个方法有着许多的实际限制，首先的问题就是所需要的额外空间是巨大的。
> 另一个问题就是编程语言中不会存储n个数字组成的整数。


> 由于直接访问表以上种种的限制，从而使得它常常不能被使用。Hashing是解决上述问题
> 的一个好方法，并且Hashing就像数组一样比以上Linked List，平衡二叉搜索树这些数据结构在实际中
> 表现的都更好。对于Hashing如果合理的情况下平均时间复杂度为O(1)，然而最坏的情况下时间复杂度
> 为O(n)。  
> Hashing是对直接访问表的一种改善，主要思路是将一个给定的电话号码或其他键转换为更小的数字，
> 使用更小的数字作为一个表的索引，这样的表称为hash table。

