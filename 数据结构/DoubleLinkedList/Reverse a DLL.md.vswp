vnote_backup_file_826537664 F:/VNote/数据结构/DoubleLinkedList/Reverse a DLL.md
# Reverse a Doublely Linked List

> 给定一个DLL，写一个方法倒置DLL

> 如下图一个初始化的DLL

> ![初始状态的DLL](_v_images/20190224195800607_7330.jpg)

>经过倒置后，使得DLL成如下形式

>![倒置后的DLL](_v_images/20190224195857681_3812.jpg)

> 有一个简单的方法用于倒置一个DLL，我们只需要将DLL中所有节点的prev指针和next指针交换即可，再把
> 头指针指向原来的尾部，头结点的prev设为NULL即可。

## 主要代码如下

```c++
    void reverseDLL(Node ** head_ref)
    {
    	struct Node* temp = NULL;
    	struct Node* current = *head_ref;
    	//swap next pointer and prev pointer
    	//for all nodes of DLL
    	while (current != NULL)
    	{
    		temp = current->prev;
    		current->prev = current->next;
    		current->next = temp;
    		//指针向下移动一个节点
    		current = current->prev;
    	}
    	//before changing head,check for the cases
    	//like empty list and list with only one node
    	if (temp != NULL)
    	{

    		*head_ref = temp->prev;
    	}

    }
```

## 完整代码

```c++
    #include<iostream>
    #include<cstdlib>
    #include<cstdio>

    using namespace std;

    //insert a new node on the front of the list
    void push(struct Node** head_ref, int data);
    //print the content of the list
    void printList(struct Node* head);
    //reverse a DLL
    void reverseDLL(struct Node** head_ref);

    struct  Node
    {
    	int data;
    	struct Node* next;
    	struct Node* prev;
    };

    void printList(struct Node* head) {
    	struct Node* head_node = head;
    	//指向尾节点的指针
    	struct Node* last_node = NULL;
    	//正向打印
    	printf("Traversal in forward deriction：");
    	while (head_node != NULL)
    	{
    		printf("%d->", head_node->data);
    		//这条语句要写在这里不能写在下面那条语句之后，因为最后一次执行循环完之后的head_node的next
    		//指针指向的是NULL，last_node如果写在之后将是NULL
    		last_node = head_node;
    		head_node = head_node->next;
    	}
    	printf("\n");
    	//逆向打印
    	printf("Traversal in reverse direction：");
    	while (last_node != NULL)
    	{
    		printf("%d->", last_node->data);
    		last_node = last_node->prev;
    	}
    }

    void push(struct Node** head_ref, int newData) {
    	//1.allocae memory
    	struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    	int size = sizeof(struct Node);
    	//2.put int the data
    	new_node->data = newData;
    	//3. make the next of new node as head and previous as NULL
    	new_node->next = *head_ref;
    	new_node->prev = NULL;

    	//4.change prev of head node to new node
    	if ((*head_ref) != NULL)
    	{
    		(*head_ref)->prev = new_node;
    	}

    	//5.move the head to point to the new node
    	*head_ref = new_node;
    }

    int main() {

    	struct Node* head = NULL;
    	push(&head, 5);
    	push(&head, 4);
    	push(&head, 3);
    	push(&head, 2);
    	push(&head, 1);
    	printf("the list is:\n");
    	printList(head);

    	printf("\n");
    	reverseDLL(&head);
    	printf("After Reverse DLL:\n");

    	printList(head);
    }


    void reverseDLL(Node ** head_ref)
    {
    	struct Node* temp = NULL;
    	struct Node* current = *head_ref;
    	//swap next pointer and prev pointer
    	//for all nodes of DLL
    	while (current != NULL)
    	{
    		temp = current->prev;
    		current->prev = current->next;
    		current->next = temp;
    		//指针向下移动一个节点
    		current = current->prev;
    	}
    	//before changing head,check for the cases
    	//like empty list and list with only one node
    	if (temp != NULL)
    	{

    		*head_ref = temp->prev;
    	}

    }
```

## 程序运行效果
![倒置DLL的结果](_v_images/20190225224435276_25811.png)

## 步骤详解

## 分析
>该倒置的方法即把DLL中所有的节点的prev指针和next指针交换指向的节点即可，

